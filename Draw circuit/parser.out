Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AC
    ARROW
    LBRACE
    OP
    PARALLEL
    RBRACE
    SEMICOLON
    SERIES
    SUBCIRCUIT
    TRANSIENT

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statement
Rule 3     statements -> statements statement
Rule 4     statement -> component_decl
Rule 5     statement -> let_statement
Rule 6     let_statement -> LET IDENTIFIER EQUALS expression
Rule 7     let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression
Rule 8     component_decl -> IDENTIFIER EQUALS component_value
Rule 9     component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref
Rule 10    component_value -> IDENTIFIER
Rule 11    component_value -> NUMBER
Rule 12    node_ref -> IDENTIFIER
Rule 13    expression -> term
Rule 14    expression -> expression PLUS term
Rule 15    expression -> expression MINUS term
Rule 16    term -> factor
Rule 17    term -> term TIMES factor
Rule 18    term -> term DIVIDE factor
Rule 19    factor -> NUMBER
Rule 20    factor -> IDENTIFIER
Rule 21    factor -> LPAREN expression RPAREN
Rule 22    factor -> PLUS factor
Rule 23    factor -> MINUS factor

Terminals, with rules where they appear

AC                   : 
ARROW                : 
COLON                : 9
COMMA                : 7 9
DIVIDE               : 18
EQUALS               : 6 7 7 8 9
IDENTIFIER           : 6 7 7 8 9 10 12 20
LBRACE               : 
LET                  : 6 7
LPAREN               : 21
MINUS                : 15 23
NUMBER               : 11 19
OP                   : 
PARALLEL             : 
PLUS                 : 14 22
RBRACE               : 
RPAREN               : 21
SEMICOLON            : 
SERIES               : 
SUBCIRCUIT           : 
TIMES                : 17
TRANSIENT            : 
error                : 

Nonterminals, with rules where they appear

component_decl       : 4
component_value      : 8 9
expression           : 6 7 7 14 15 21
factor               : 16 17 18 22 23
let_statement        : 5
node_ref             : 9 9
program              : 0
statement            : 2 3
statements           : 1 3
term                 : 13 14 15 17 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statement
    (3) statements -> . statements statement
    (4) statement -> . component_decl
    (5) statement -> . let_statement
    (8) component_decl -> . IDENTIFIER EQUALS component_value
    (9) component_decl -> . IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref
    (6) let_statement -> . LET IDENTIFIER EQUALS expression
    (7) let_statement -> . LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 6
    LET             shift and go to state 7

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    component_decl                 shift and go to state 4
    let_statement                  shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (3) statements -> statements . statement
    (4) statement -> . component_decl
    (5) statement -> . let_statement
    (8) component_decl -> . IDENTIFIER EQUALS component_value
    (9) component_decl -> . IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref
    (6) let_statement -> . LET IDENTIFIER EQUALS expression
    (7) let_statement -> . LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression

    $end            reduce using rule 1 (program -> statements .)
    IDENTIFIER      shift and go to state 6
    LET             shift and go to state 7

    statement                      shift and go to state 8
    component_decl                 shift and go to state 4
    let_statement                  shift and go to state 5

state 3

    (2) statements -> statement .

    IDENTIFIER      reduce using rule 2 (statements -> statement .)
    LET             reduce using rule 2 (statements -> statement .)
    $end            reduce using rule 2 (statements -> statement .)


state 4

    (4) statement -> component_decl .

    IDENTIFIER      reduce using rule 4 (statement -> component_decl .)
    LET             reduce using rule 4 (statement -> component_decl .)
    $end            reduce using rule 4 (statement -> component_decl .)


state 5

    (5) statement -> let_statement .

    IDENTIFIER      reduce using rule 5 (statement -> let_statement .)
    LET             reduce using rule 5 (statement -> let_statement .)
    $end            reduce using rule 5 (statement -> let_statement .)


state 6

    (8) component_decl -> IDENTIFIER . EQUALS component_value
    (9) component_decl -> IDENTIFIER . EQUALS component_value COLON node_ref COMMA node_ref

    EQUALS          shift and go to state 9


state 7

    (6) let_statement -> LET . IDENTIFIER EQUALS expression
    (7) let_statement -> LET . IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 10


state 8

    (3) statements -> statements statement .

    IDENTIFIER      reduce using rule 3 (statements -> statements statement .)
    LET             reduce using rule 3 (statements -> statements statement .)
    $end            reduce using rule 3 (statements -> statements statement .)


state 9

    (8) component_decl -> IDENTIFIER EQUALS . component_value
    (9) component_decl -> IDENTIFIER EQUALS . component_value COLON node_ref COMMA node_ref
    (10) component_value -> . IDENTIFIER
    (11) component_value -> . NUMBER

    IDENTIFIER      shift and go to state 11
    NUMBER          shift and go to state 13

    component_value                shift and go to state 12

state 10

    (6) let_statement -> LET IDENTIFIER . EQUALS expression
    (7) let_statement -> LET IDENTIFIER . EQUALS expression COMMA IDENTIFIER EQUALS expression

    EQUALS          shift and go to state 14


state 11

    (10) component_value -> IDENTIFIER .

    COLON           reduce using rule 10 (component_value -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 10 (component_value -> IDENTIFIER .)
    LET             reduce using rule 10 (component_value -> IDENTIFIER .)
    $end            reduce using rule 10 (component_value -> IDENTIFIER .)


state 12

    (8) component_decl -> IDENTIFIER EQUALS component_value .
    (9) component_decl -> IDENTIFIER EQUALS component_value . COLON node_ref COMMA node_ref

    IDENTIFIER      reduce using rule 8 (component_decl -> IDENTIFIER EQUALS component_value .)
    LET             reduce using rule 8 (component_decl -> IDENTIFIER EQUALS component_value .)
    $end            reduce using rule 8 (component_decl -> IDENTIFIER EQUALS component_value .)
    COLON           shift and go to state 15


state 13

    (11) component_value -> NUMBER .

    COLON           reduce using rule 11 (component_value -> NUMBER .)
    IDENTIFIER      reduce using rule 11 (component_value -> NUMBER .)
    LET             reduce using rule 11 (component_value -> NUMBER .)
    $end            reduce using rule 11 (component_value -> NUMBER .)


state 14

    (6) let_statement -> LET IDENTIFIER EQUALS . expression
    (7) let_statement -> LET IDENTIFIER EQUALS . expression COMMA IDENTIFIER EQUALS expression
    (13) expression -> . term
    (14) expression -> . expression PLUS term
    (15) expression -> . expression MINUS term
    (16) term -> . factor
    (17) term -> . term TIMES factor
    (18) term -> . term DIVIDE factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    expression                     shift and go to state 17
    term                           shift and go to state 18
    factor                         shift and go to state 21

state 15

    (9) component_decl -> IDENTIFIER EQUALS component_value COLON . node_ref COMMA node_ref
    (12) node_ref -> . IDENTIFIER

    IDENTIFIER      shift and go to state 24

    node_ref                       shift and go to state 25

state 16

    (20) factor -> IDENTIFIER .

    TIMES           reduce using rule 20 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 20 (factor -> IDENTIFIER .)
    COMMA           reduce using rule 20 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 20 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 20 (factor -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 20 (factor -> IDENTIFIER .)
    LET             reduce using rule 20 (factor -> IDENTIFIER .)
    $end            reduce using rule 20 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 20 (factor -> IDENTIFIER .)


state 17

    (6) let_statement -> LET IDENTIFIER EQUALS expression .
    (7) let_statement -> LET IDENTIFIER EQUALS expression . COMMA IDENTIFIER EQUALS expression
    (14) expression -> expression . PLUS term
    (15) expression -> expression . MINUS term

    IDENTIFIER      reduce using rule 6 (let_statement -> LET IDENTIFIER EQUALS expression .)
    LET             reduce using rule 6 (let_statement -> LET IDENTIFIER EQUALS expression .)
    $end            reduce using rule 6 (let_statement -> LET IDENTIFIER EQUALS expression .)
    COMMA           shift and go to state 26
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 18

    (13) expression -> term .
    (17) term -> term . TIMES factor
    (18) term -> term . DIVIDE factor

    COMMA           reduce using rule 13 (expression -> term .)
    PLUS            reduce using rule 13 (expression -> term .)
    MINUS           reduce using rule 13 (expression -> term .)
    IDENTIFIER      reduce using rule 13 (expression -> term .)
    LET             reduce using rule 13 (expression -> term .)
    $end            reduce using rule 13 (expression -> term .)
    RPAREN          reduce using rule 13 (expression -> term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 19

    (22) factor -> PLUS . factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    factor                         shift and go to state 31

state 20

    (23) factor -> MINUS . factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    factor                         shift and go to state 32

state 21

    (16) term -> factor .

    TIMES           reduce using rule 16 (term -> factor .)
    DIVIDE          reduce using rule 16 (term -> factor .)
    COMMA           reduce using rule 16 (term -> factor .)
    PLUS            reduce using rule 16 (term -> factor .)
    MINUS           reduce using rule 16 (term -> factor .)
    IDENTIFIER      reduce using rule 16 (term -> factor .)
    LET             reduce using rule 16 (term -> factor .)
    $end            reduce using rule 16 (term -> factor .)
    RPAREN          reduce using rule 16 (term -> factor .)


state 22

    (19) factor -> NUMBER .

    TIMES           reduce using rule 19 (factor -> NUMBER .)
    DIVIDE          reduce using rule 19 (factor -> NUMBER .)
    COMMA           reduce using rule 19 (factor -> NUMBER .)
    PLUS            reduce using rule 19 (factor -> NUMBER .)
    MINUS           reduce using rule 19 (factor -> NUMBER .)
    IDENTIFIER      reduce using rule 19 (factor -> NUMBER .)
    LET             reduce using rule 19 (factor -> NUMBER .)
    $end            reduce using rule 19 (factor -> NUMBER .)
    RPAREN          reduce using rule 19 (factor -> NUMBER .)


state 23

    (21) factor -> LPAREN . expression RPAREN
    (13) expression -> . term
    (14) expression -> . expression PLUS term
    (15) expression -> . expression MINUS term
    (16) term -> . factor
    (17) term -> . term TIMES factor
    (18) term -> . term DIVIDE factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    expression                     shift and go to state 33
    term                           shift and go to state 18
    factor                         shift and go to state 21

state 24

    (12) node_ref -> IDENTIFIER .

    COMMA           reduce using rule 12 (node_ref -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 12 (node_ref -> IDENTIFIER .)
    LET             reduce using rule 12 (node_ref -> IDENTIFIER .)
    $end            reduce using rule 12 (node_ref -> IDENTIFIER .)


state 25

    (9) component_decl -> IDENTIFIER EQUALS component_value COLON node_ref . COMMA node_ref

    COMMA           shift and go to state 34


state 26

    (7) let_statement -> LET IDENTIFIER EQUALS expression COMMA . IDENTIFIER EQUALS expression

    IDENTIFIER      shift and go to state 35


state 27

    (14) expression -> expression PLUS . term
    (16) term -> . factor
    (17) term -> . term TIMES factor
    (18) term -> . term DIVIDE factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    term                           shift and go to state 36
    factor                         shift and go to state 21

state 28

    (15) expression -> expression MINUS . term
    (16) term -> . factor
    (17) term -> . term TIMES factor
    (18) term -> . term DIVIDE factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    term                           shift and go to state 37
    factor                         shift and go to state 21

state 29

    (17) term -> term TIMES . factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    factor                         shift and go to state 38

state 30

    (18) term -> term DIVIDE . factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    factor                         shift and go to state 39

state 31

    (22) factor -> PLUS factor .

    TIMES           reduce using rule 22 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 22 (factor -> PLUS factor .)
    COMMA           reduce using rule 22 (factor -> PLUS factor .)
    PLUS            reduce using rule 22 (factor -> PLUS factor .)
    MINUS           reduce using rule 22 (factor -> PLUS factor .)
    IDENTIFIER      reduce using rule 22 (factor -> PLUS factor .)
    LET             reduce using rule 22 (factor -> PLUS factor .)
    $end            reduce using rule 22 (factor -> PLUS factor .)
    RPAREN          reduce using rule 22 (factor -> PLUS factor .)


state 32

    (23) factor -> MINUS factor .

    TIMES           reduce using rule 23 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 23 (factor -> MINUS factor .)
    COMMA           reduce using rule 23 (factor -> MINUS factor .)
    PLUS            reduce using rule 23 (factor -> MINUS factor .)
    MINUS           reduce using rule 23 (factor -> MINUS factor .)
    IDENTIFIER      reduce using rule 23 (factor -> MINUS factor .)
    LET             reduce using rule 23 (factor -> MINUS factor .)
    $end            reduce using rule 23 (factor -> MINUS factor .)
    RPAREN          reduce using rule 23 (factor -> MINUS factor .)


state 33

    (21) factor -> LPAREN expression . RPAREN
    (14) expression -> expression . PLUS term
    (15) expression -> expression . MINUS term

    RPAREN          shift and go to state 40
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 34

    (9) component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA . node_ref
    (12) node_ref -> . IDENTIFIER

    IDENTIFIER      shift and go to state 24

    node_ref                       shift and go to state 41

state 35

    (7) let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER . EQUALS expression

    EQUALS          shift and go to state 42


state 36

    (14) expression -> expression PLUS term .
    (17) term -> term . TIMES factor
    (18) term -> term . DIVIDE factor

    COMMA           reduce using rule 14 (expression -> expression PLUS term .)
    PLUS            reduce using rule 14 (expression -> expression PLUS term .)
    MINUS           reduce using rule 14 (expression -> expression PLUS term .)
    IDENTIFIER      reduce using rule 14 (expression -> expression PLUS term .)
    LET             reduce using rule 14 (expression -> expression PLUS term .)
    $end            reduce using rule 14 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 14 (expression -> expression PLUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 37

    (15) expression -> expression MINUS term .
    (17) term -> term . TIMES factor
    (18) term -> term . DIVIDE factor

    COMMA           reduce using rule 15 (expression -> expression MINUS term .)
    PLUS            reduce using rule 15 (expression -> expression MINUS term .)
    MINUS           reduce using rule 15 (expression -> expression MINUS term .)
    IDENTIFIER      reduce using rule 15 (expression -> expression MINUS term .)
    LET             reduce using rule 15 (expression -> expression MINUS term .)
    $end            reduce using rule 15 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 15 (expression -> expression MINUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 38

    (17) term -> term TIMES factor .

    TIMES           reduce using rule 17 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 17 (term -> term TIMES factor .)
    COMMA           reduce using rule 17 (term -> term TIMES factor .)
    PLUS            reduce using rule 17 (term -> term TIMES factor .)
    MINUS           reduce using rule 17 (term -> term TIMES factor .)
    IDENTIFIER      reduce using rule 17 (term -> term TIMES factor .)
    LET             reduce using rule 17 (term -> term TIMES factor .)
    $end            reduce using rule 17 (term -> term TIMES factor .)
    RPAREN          reduce using rule 17 (term -> term TIMES factor .)


state 39

    (18) term -> term DIVIDE factor .

    TIMES           reduce using rule 18 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 18 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 18 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 18 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 18 (term -> term DIVIDE factor .)
    IDENTIFIER      reduce using rule 18 (term -> term DIVIDE factor .)
    LET             reduce using rule 18 (term -> term DIVIDE factor .)
    $end            reduce using rule 18 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 18 (term -> term DIVIDE factor .)


state 40

    (21) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    LET             reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 21 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 21 (factor -> LPAREN expression RPAREN .)


state 41

    (9) component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref .

    IDENTIFIER      reduce using rule 9 (component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref .)
    LET             reduce using rule 9 (component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref .)
    $end            reduce using rule 9 (component_decl -> IDENTIFIER EQUALS component_value COLON node_ref COMMA node_ref .)


state 42

    (7) let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS . expression
    (13) expression -> . term
    (14) expression -> . expression PLUS term
    (15) expression -> . expression MINUS term
    (16) term -> . factor
    (17) term -> . term TIMES factor
    (18) term -> . term DIVIDE factor
    (19) factor -> . NUMBER
    (20) factor -> . IDENTIFIER
    (21) factor -> . LPAREN expression RPAREN
    (22) factor -> . PLUS factor
    (23) factor -> . MINUS factor

    NUMBER          shift and go to state 22
    IDENTIFIER      shift and go to state 16
    LPAREN          shift and go to state 23
    PLUS            shift and go to state 19
    MINUS           shift and go to state 20

    expression                     shift and go to state 43
    term                           shift and go to state 18
    factor                         shift and go to state 21

state 43

    (7) let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression .
    (14) expression -> expression . PLUS term
    (15) expression -> expression . MINUS term

    IDENTIFIER      reduce using rule 7 (let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression .)
    LET             reduce using rule 7 (let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression .)
    $end            reduce using rule 7 (let_statement -> LET IDENTIFIER EQUALS expression COMMA IDENTIFIER EQUALS expression .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28

